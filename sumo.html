<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Sumo - Fight for ETH</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Previene el scroll en el body */
            padding: 20px; /* Espacio alrededor del contenedor del juego */
        }
        
        .game-container {
            text-align: center;
            max-width: 800px;
            width: 100%;
            padding: 20px; /* Padding interno para el contenido del contenedor */
            background: rgba(0,0,0,0.2); /* Fondo sutil para ver los l√≠mites */
            border-radius: 15px;
            max-height: calc(100vh - 40px); /* Altura m√°xima = alto de ventana - padding vertical del body */
            overflow-y: auto; /* Permite scroll vertical interno si el contenido excede max-height */
            display: flex;
            flex-direction: column; /* Apila los hijos verticalmente */
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .game-info {
            display: flex;
            justify-content: space-around; /* Distribuye el espacio */
            margin-bottom: 20px;
            padding: 0 10px; 
            width: 100%;
        }
        
        .wallet-info, .game-stats {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            flex-basis: 45%; /* Cada uno toma ~45% del espacio */
            min-width: 180px; /* Ancho m√≠nimo para evitar que se compriman demasiado */
        }
        
        #gameCanvas {
            border: 5px solid #FFD700;
            border-radius: 50%;
            background: radial-gradient(circle, #4a5568 0%, #2d3748 100%);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            margin: 20px auto; /* Centra el canvas */
            display: block;
            /* width y height se establecen en los atributos HTML (600x600) */
            max-width: 100%; /* Asegura que el canvas no desborde su contenedor si es muy estrecho */
        }
        
        .controls {
            margin: 20px 0;
            width: 100%; /* Asegura que los controles usen el ancho completo para centrar su contenido */
        }
        
        .btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            color: #333;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input {
            padding: 10px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.9);
            color: #333;
        }
        
        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }
        
        .player-list {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .player-card {
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 8px;
            min-width: 120px;
        }
        
        .countdown {
            font-size: 2rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .powerup-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }
    </style>
    <!-- Reemplazar Viem con ethers.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.5/ethers.umd.min.js" type="application/javascript"></script>
</head>
<body>
    <div class="game-container">
        <h1>‚ö° CRYPTO SUMO ‚ö°</h1>
        
        <div class="game-info">
            <div class="wallet-info">
                <h3>üí∞ Wallet</h3>
                <p id="walletAddress">Not Connected</p>
                <div class="wallet-buttons">
                    <button class="btn" id="connectWallet">Connect Wallet</button>
                    <button class="btn" id="disconnectWallet" style="display:none; background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">Disconnect</button>
                </div>
                <p id="networkStatus" style="font-size: 12px; margin-top: 5px;"></p>
            </div>
            <div class="game-stats">
                <h3>üèÜ Game Stats</h3>
                <p>Prize Pool: <span id="prizePool">0</span> FLOW</p>
                <p>Players: <span id="playerCount">0</span></p>
                <p class="countdown" id="gameTimer"></p>
            </div>
        </div>
        
        <div class="controls">
            <input type="number" id="betAmount" placeholder="Bet Amount (FLOW)" step="0.001" min="0.001" value="0.01">
            <button class="btn" id="joinGame">Join Game (Bet FLOW)</button>
            <button class="btn" id="startGame" style="display:none;">Start Game</button>
        </div>
        
        <div class="player-list" id="playerList"></div>
        
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <!-- 
        <div class="instructions">
            <h3>üéÆ How to Play</h3>
            <p><strong>WASD or Arrow Keys</strong> to move your sumo wrestler</p>
            <p>üí™ <strong>Bigger bet = Stronger wrestler</strong></p>
            <p>üéØ <strong>Push opponents out of the ring to win!</strong></p>
            <p>üöÄ <strong>Grab power-ups for temporary advantages</strong></p>
            <p>üèÜ <strong>Last player standing wins the entire prize pool!</strong></p>
        </div>
        -->
        
    </div>

    <script>
        // Flow Testnet Network Configuration
        const FLOW_TESTNET = {
            chainId: '0x221', // 545 in decimal
            chainName: 'Flow Testnet',
            rpcUrls: ['https://testnet.evm.nodes.onflow.org'],
            nativeCurrency: {
                name: 'FLOW',
                symbol: 'FLOW',
                decimals: 18
            },
            blockExplorerUrls: ['https://testnet.flowscan.org']
        };

        // Game State
        let gameState = {
            players: new Map(),
            powerups: [],
            gameRunning: false,
            gamePhase: 'waiting', // waiting, countdown, playing, finished
            prizePool: 0,
            myPlayerId: null,
            countdown: 0,
            gameTime: 60
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const ringRadius = 280;

        // Wallet connection
        let walletConnected = false;
        let walletAddress = '';

        // Game mechanics
        const POWERUP_TYPES = {
            STRENGTH: { emoji: 'üí™', color: '#ff4444', duration: 5000 },
            SPEED: { emoji: '‚ö°', color: '#44ff44', duration: 5000 },
            SHIELD: { emoji: 'üõ°Ô∏è', color: '#4444ff', duration: 3000 },
            MAGNET: { emoji: 'üß≤', color: '#ff44ff', duration: 4000 }
        };

        // Ethers.js variables para Ethereum
        let provider;
        let signer;

        // Precargar im√°genes de sumo
        const sumoImages = {
            default: new Image(),
            strength: new Image(),
            speed: new Image(),
            shield: new Image()
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadSumoImages();
            setupEthers();
            setupEventListeners();
            gameLoop();
            
            // Add some demo players for testing
            setTimeout(() => {
                if (gameState.players.size === 0) {
                    addDemoPlayers();
                }
            }, 1000);
        });

        // Cargar im√°genes de sumos
        function loadSumoImages() {
            // Cargar im√°genes base
            sumoImages.default.src = './public/sumo-default.png';
            sumoImages.strength.src = './public/sumo-strength.png';
            sumoImages.speed.src = './public/sumo-speed.png';
            sumoImages.shield.src = './public/sumo-shield.png';
            
            // A√±adir evento de carga para mostrar progreso
            let imagesLoaded = 0;
            const totalImages = Object.keys(sumoImages).length;
            
            Object.values(sumoImages).forEach(img => {
                img.onload = () => {
                    imagesLoaded++;
                    console.log(`Cargando im√°genes: ${imagesLoaded}/${totalImages}`);
                };
                
                img.onerror = (err) => {
                    console.error('Error cargando imagen:', err);
                };
            });
        }

        // Configuraci√≥n de ethers.js para interactuar con Ethereum
        function setupEthers() {
            try {
                // Verificar si MetaMask est√° instalado
                if (window.ethereum) {
                    // Crear provider usando el proveedor de la ventana (MetaMask) - Sintaxis Ethers v6
                    provider = new ethers.BrowserProvider(window.ethereum);
                    console.log("Ethers.js initialized with BrowserProvider (v6)");
                } else {
                    console.log("No Ethereum wallet detected"); // Este mensaje es correcto si no hay wallet
                }
            } catch (error) {
                console.error("Error setting up ethers:", error);
            }
        }

        function setupEventListeners() {
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
            document.getElementById('joinGame').addEventListener('click', joinGame);
            document.getElementById('startGame').addEventListener('click', startGame);
            
            // Keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        // Wallet functions con ethers.js
        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    alert("MetaMask or other Ethereum wallet not found! Please install MetaMask.");
                    simulateWalletConnection();
                    return;
                }
                
                // Request accounts first to ensure we're connected
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    alert("No accounts found or permission denied.");
                    simulateWalletConnection();
                    return;
                }
                
                // Show network status in UI
                document.getElementById('networkStatus').textContent = "Checking network...";
                
                // Check if we're on the correct network
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== FLOW_TESTNET.chainId) {
                    // Wrong network, prompt to switch
                    document.getElementById('networkStatus').textContent = "Switching to Flow Testnet...";
                    showMessage("Attempting to switch to Flow Testnet...");
                    
                    try {
                        const switched = await switchToFlowTestnet();
                        if (!switched) {
                            document.getElementById('networkStatus').textContent = "Please add Flow network manually";
                            showManualNetworkInstructions();
                            return;
                        }
                    } catch (switchError) {
                        console.error("Switch error:", switchError);
                        document.getElementById('networkStatus').textContent = "Network switch failed";
                        showManualNetworkInstructions();
                        return;
                    }
                }

                // Crear provider si no existe
                if (!provider) {
                    provider = new ethers.BrowserProvider(window.ethereum);
                }
                
                // Obtener el signer
                signer = await provider.getSigner();
                walletAddress = await signer.getAddress();
                walletConnected = true;
                
                // Actualizar UI
                document.getElementById('walletAddress').textContent = walletAddress.substring(0, 6) + '...' + walletAddress.substring(38);
                document.getElementById('connectWallet').style.display = 'none';
                document.getElementById('disconnectWallet').style.display = 'inline-block';
                document.getElementById('networkStatus').textContent = "Connected to Flow Testnet";
                
                // Configurar eventos para cambios en la wallet
                setupWalletEvents();
                
                // Obtener saldo
                const balance = await provider.getBalance(walletAddress);
                const etherBalance = ethers.formatEther(balance);
                
                console.log("Wallet connected:", walletAddress);
                console.log("Balance:", etherBalance, "FLOW");
                
                showMessage(`Wallet connected: ${etherBalance} FLOW`);
            } catch (error) {
                console.error("Error connecting wallet:", error);
                alert(`Error connecting wallet: ${error.message || error}`);
                document.getElementById('networkStatus').textContent = "Connection failed";
                simulateWalletConnection();
            }
        }
        
        // Function to disconnect wallet
        async function disconnectWallet() {
            try {
                // Reset wallet state
                walletConnected = false;
                walletAddress = '';
                signer = null;
                
                // Update UI
                document.getElementById('walletAddress').textContent = 'Not Connected';
                document.getElementById('connectWallet').style.display = 'inline-block';
                document.getElementById('disconnectWallet').style.display = 'none';
                document.getElementById('networkStatus').textContent = '';
                document.getElementById('joinGame').disabled = false;
                document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
                
                // Note: MetaMask doesn't have a direct disconnect method from dApps
                // We're just resetting our app's connection state
                
                showMessage('Wallet disconnected');
                
                // If player is in game, we may want to handle that
                if (gameState.myPlayerId) {
                    // This would depend on your game logic
                    // Possibly remove player or mark as disconnected
                }
                
            } catch (error) {
                console.error("Error disconnecting wallet:", error);
                showMessage('Error disconnecting wallet');
            }
        }
        
        // Function to display manual network adding instructions
        function showManualNetworkInstructions() {
            const instructions = document.createElement('div');
            instructions.style.position = 'fixed';
            instructions.style.top = '50%';
            instructions.style.left = '50%';
            instructions.style.transform = 'translate(-50%, -50%)';
            instructions.style.background = 'rgba(0,0,0,0.9)';
            instructions.style.color = 'white';
            instructions.style.padding = '20px';
            instructions.style.borderRadius = '10px';
            instructions.style.maxWidth = '400px';
            instructions.style.zIndex = '1001';
            instructions.innerHTML = `
                <h3 style="color: #FFD700;">Add Flow Network Manually</h3>
                <p>Please add Flow Testnet to your wallet with these details:</p>
                <ul style="text-align: left; margin: 15px 0;">
                    <li>Network Name: Flow Testnet</li>
                    <li>RPC URL: https://testnet.evm.nodes.onflow.org</li>
                    <li>Chain ID: 545 (0x221)</li>
                    <li>Currency Symbol: FLOW</li>
                    <li>Block Explorer: https://testnet.flowscan.org</li>
                </ul>
                <button id="closeInstructions" class="btn" style="margin-top: 10px;">Close</button>
                <button id="tryAgain" class="btn" style="margin-top: 10px; margin-left: 10px;">Try Again</button>
            `;
            
            document.body.appendChild(instructions);
            
            document.getElementById('closeInstructions').addEventListener('click', () => {
                document.body.removeChild(instructions);
            });
            
            document.getElementById('tryAgain').addEventListener('click', () => {
                document.body.removeChild(instructions);
                connectWallet();
            });
        }
        
        // Function to switch to Flow Testnet with improved error handling
        async function switchToFlowTestnet() {
            try {
                console.log("Attempting to switch to Flow Testnet, chainId:", FLOW_TESTNET.chainId);
                
                // First try to switch to the network
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: FLOW_TESTNET.chainId }],
                });
                console.log("Network switch successful");
                return true;
            } catch (switchError) {
                console.log("Switch error:", switchError);
                console.log("Switch error code:", switchError.code);
                
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902 || switchError.message.includes("wallet_addEthereumChain")) {
                    try {
                        console.log("Attempting to add Flow Testnet to wallet");
                        // Add the network to MetaMask
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: FLOW_TESTNET.chainId,
                                    chainName: FLOW_TESTNET.chainName,
                                    nativeCurrency: FLOW_TESTNET.nativeCurrency,
                                    rpcUrls: FLOW_TESTNET.rpcUrls,
                                    blockExplorerUrls: FLOW_TESTNET.blockExplorerUrls
                                }
                            ],
                        });
                        
                        // Verify the switch was successful
                        const newChainId = await window.ethereum.request({ method: 'eth_chainId' });
                        console.log("New chain ID after add:", newChainId);
                        return newChainId === FLOW_TESTNET.chainId;
                        
                    } catch (addError) {
                        console.error('Error adding Flow Testnet to wallet:', addError);
                        return false;
                    }
                }
                // Other errors
                console.error('Error switching to Flow Testnet:', switchError);
                return false;
            }
        }
        
        // Modificar setupWalletEvents para verificar la red en cambios de cadena
        function setupWalletEvents() {
            if (!window.ethereum) return;
            
            // Remover listeners anteriores para evitar duplicados
            try {
                window.ethereum.removeAllListeners('accountsChanged');
                window.ethereum.removeAllListeners('chainChanged');
            } catch (error) {
                console.log('No previous listeners to remove');
            }
            
            const handleAccountsChanged = async (accounts) => {
                console.log('Accounts changed:', accounts);
                if (accounts.length === 0) {
                    // Usuario desconect√≥ su wallet desde MetaMask
                    disconnectWallet(); // Use our disconnect function
                } else {
                    // Usuario cambi√≥ de cuenta
                    try {
                        walletAddress = accounts[0];
                        document.getElementById('walletAddress').textContent = walletAddress.substring(0, 6) + '...' + walletAddress.substring(38);
                        if (provider) {
                            signer = await provider.getSigner();
                        }
                        showMessage('Account changed');
                    } catch (error) {
                        console.error('Error handling account change:', error);
                    }
                }
            };
            
            const handleChainChanged = async (chainId) => {
                console.log('Chain changed to:', chainId);
                
                // Check if new chain is Flow Testnet
                if (chainId !== FLOW_TESTNET.chainId) {
                    document.getElementById('networkStatus').textContent = "Wrong network";
                    showMessage('Wrong network! Please switch to Flow Testnet', 5000);
                    document.getElementById('joinGame').disabled = true;
                    
                    // Add option to switch back
                    const switchButton = document.createElement('button');
                    switchButton.className = 'btn';
                    switchButton.textContent = 'Switch to Flow Testnet';
                    switchButton.style.margin = '10px auto';
                    switchButton.style.display = 'block';
                    
                    switchButton.onclick = async () => {
                        await switchToFlowTestnet();
                        document.body.removeChild(switchButton);
                    };
                    
                    document.body.appendChild(switchButton);
                } else {
                    document.getElementById('networkStatus').textContent = "Connected to Flow Testnet";
                    document.getElementById('joinGame').disabled = false;
                    showMessage('Connected to Flow Testnet ‚úì');
                }
            };
            
            // Usar try-catch para manejar diferentes versiones de MetaMask
            try {
                if (window.ethereum.on) {
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);
                } else if (window.ethereum.addEventListener) {
                    window.ethereum.addEventListener('accountsChanged', handleAccountsChanged);
                    window.ethereum.addEventListener('chainChanged', handleChainChanged);
                } else {
                    console.log('MetaMask event listeners not supported');
                }
            } catch (error) {
                console.error('Error setting up wallet events:', error);
                // Continuar sin event listeners si hay problemas
            }
        }

        // Game functions - Modificar joinGame para usar ethers.js
        async function joinGame() {
            if (!walletConnected) {
                alert('Please connect your wallet first!');
                return;
            }

            try {
                // Verificar red correcta
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== FLOW_TESTNET.chainId) {
                    alert('Please switch to Flow Testnet to play!');
                    const switched = await switchToFlowTestnet();
                    if (!switched) {
                        showManualNetworkInstructions();
                        return;
                    }
                }

                const betAmount = parseFloat(document.getElementById('betAmount').value);
                if (betAmount < 0.001) {
                    alert('Minimum bet is 0.001 FLOW');
                    return;
                }
                
                // Si estamos en modo demo (sin wallet real o signer), simular la transacci√≥n
                if (!signer) {
                    simulateJoinGame(betAmount);
                    return;
                }

                // Mostrar que estamos procesando
                document.getElementById('joinGame').disabled = true;
                document.getElementById('joinGame').textContent = 'Processing...';
                
                // Obtener saldo para verificar
                const balance = await provider.getBalance(walletAddress);
                const betAmountWei = ethers.parseEther(betAmount.toString());
                
                // Verificar que tiene suficiente saldo
                if (balance < betAmountWei) {
                    alert(`Insufficient balance. You have ${ethers.formatEther(balance)} FLOW.`);
                    document.getElementById('joinGame').disabled = false;
                    document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
                    return;
                }
                
                // En un juego real, aqu√≠ enviar√≠as FLOW a un contrato inteligente
                // Por ahora, simulamos una transacci√≥n exitosa
                
                // Simular transacci√≥n (en producci√≥n, aqu√≠ ir√≠a el env√≠o real)
                showMessage(`Processing ${betAmount} FLOW bet...`, 1500);
                
                /*
                // C√≥digo para enviar FLOW a un contrato (descomentarlo cuando tengas un contrato real)
                const tx = await signer.sendTransaction({
                    to: "0xContractAddressHere", // Direcci√≥n del contrato del juego
                    value: betAmountWei,
                    gasLimit: 100000
                });
                
                // Esperar confirmaci√≥n
                await tx.wait();
                */
                
                setTimeout(() => {
                    // Crear jugador despu√©s de la "transacci√≥n"
                    createPlayer(betAmount);
                    showMessage(`Bet of ${betAmount} FLOW confirmed! üéâ`);
                    
                    document.getElementById('joinGame').textContent = 'Joined ‚úì';
                }, 2000);
                
            } catch (error) {
                console.error("Error placing bet:", error);
                alert(`Error placing bet: ${error.message}`);
                document.getElementById('joinGame').disabled = false;
                document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
            }
        }
        
        // Simular unirse al juego (para demo)
        function simulateJoinGame(betAmount) {
            document.getElementById('joinGame').disabled = true;
            document.getElementById('joinGame').textContent = 'Processing...';
            
            setTimeout(() => {
                createPlayer(betAmount);
                
                // Mensaje de confirmaci√≥n
                showMessage(`Bet of ${betAmount} FLOW confirmed! üéâ`);
                document.getElementById('joinGame').textContent = 'Joined ‚úì';
            }, 1500);
        }
        
        // Funci√≥n para crear jugador (separada para reutilizar)
        function createPlayer(betAmount) {
            const playerId = walletAddress;
            gameState.myPlayerId = playerId;
            
            const player = {
                id: playerId,
                address: walletAddress,
                bet: betAmount,
                x: centerX + (Math.random() - 0.5) * 200,
                y: centerY + (Math.random() - 0.5) * 200,
                vx: 0,
                vy: 0,
                radius: Math.max(15, Math.min(35, 15 + betAmount * 500)),
                color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                alive: true,
                powerup: null,
                powerupEndTime: 0,
                keys: {},
                rotation: Math.random() * Math.PI * 2, // Rotaci√≥n aleatoria inicial
                rotationSpeed: 0
            };

            gameState.players.set(playerId, player);
            gameState.prizePool += betAmount;
            
            updateUI();
            document.getElementById('startGame').style.display = 'inline-block';
        }

        // Funci√≥n simulaci√≥n sigue siendo √∫til para pruebas
        function simulateWalletConnection() {
            walletAddress = '0x' + Math.random().toString(16).substring(2, 42);
            walletConnected = true;
            document.getElementById('walletAddress').textContent = walletAddress.substring(0, 6) + '...' + walletAddress.substring(38);
            document.getElementById('connectWallet').textContent = 'Connected ‚úì';
            document.getElementById('connectWallet').disabled = true;
        }

        // Game functions
        function startGame() {
            if (gameState.players.size < 2) {
                alert('Need at least 2 players to start!');
                return;
            }
            
            gameState.gamePhase = 'countdown';
            gameState.countdown = 3;
            document.getElementById('startGame').style.display = 'none';
            
            const countdownInterval = setInterval(() => {
                gameState.countdown--;
                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    gameState.gamePhase = 'playing';
                    gameState.gameRunning = true;
                    startGameTimer();
                    spawnPowerup();
                }
            }, 1000);
        }

        function startGameTimer() {
            gameState.gameTime = 60;
            const timer = setInterval(() => {
                gameState.gameTime--;
                updateUI(); // Ensure UI updates during game
                
                const alivePlayers = getAlivePlayers();
                // Only end game if time is up OR only one player remains
                if (gameState.gameTime <= 0 || alivePlayers.length <= 1) {
                    clearInterval(timer);
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            gameState.gameRunning = false;
            gameState.gamePhase = 'finished';
            
            const alivePlayers = getAlivePlayers();
            if (alivePlayers.length === 1) {
                const winner = alivePlayers[0];
                setTimeout(() => {
                    alert(`üèÜ Winner: ${winner.address.substring(0, 8)}... wins ${gameState.prizePool.toFixed(3)} FLOW!`);
                    resetGame();
                }, 500);
            } else if (alivePlayers.length === 0) {
                setTimeout(() => {
                    alert('üí• All players eliminated! No winner this round.');
                    resetGame();
                }, 500);
            } else {
                setTimeout(() => {
                    alert('üïê Time up! No clear winner this round.');
                    resetGame();
                }, 500);
            }
        }

        function resetGame() {
            // Reset game state for a new round
            gameState = {
                players: new Map(),
                powerups: [],
                gameRunning: false,
                gamePhase: 'waiting',
                prizePool: 0,
                myPlayerId: null,
                countdown: 0,
                gameTime: 60
            };
            
            // Re-enable UI controls
            document.getElementById('joinGame').disabled = false;
            document.getElementById('startGame').style.display = 'none';
            document.getElementById('connectWallet').disabled = walletConnected;
            
            // Clear player input state
            Object.keys(keys).forEach(key => keys[key] = false);
            
            updateUI();
            
            // Add demo players again for testing
            setTimeout(() => {
                if (gameState.players.size === 0) {
                    addDemoPlayers();
                }
            }, 1000);
        }

        function addDemoPlayers() {
            // Add some AI players for demo
            const demoPlayers = [
                { bet: 0.005, color: '#ff6b6b' },
                { bet: 0.015, color: '#4ecdc4' },
                { bet: 0.008, color: '#45b7d1' }
            ];
            
            demoPlayers.forEach((demo, i) => {
                const playerId = `demo_${i}`;
                const player = {
                    id: playerId,
                    address: '0x' + Math.random().toString(16).substring(2, 42),
                    bet: demo.bet,
                    x: centerX + (Math.random() - 0.5) * 200,
                    y: centerY + (Math.random() - 0.5) * 200,
                    vx: 0,
                    vy: 0,
                    radius: Math.max(15, Math.min(35, 15 + demo.bet * 500)),
                    color: demo.color,
                    alive: true,
                    powerup: null,
                    powerupEndTime: 0,
                    keys: {},
                    isAI: true,
                    rotation: Math.random() * Math.PI * 2, // Rotaci√≥n aleatoria inicial
                    rotationSpeed: 0
                };
                
                gameState.players.set(playerId, player);
                gameState.prizePool += demo.bet;
            });
            
            updateUI();
        }

        // Input handling
        const keys = {};
        function handleKeyDown(e) {
            if (!gameState.gameRunning) return; // Only process input during active game
            
            keys[e.key.toLowerCase()] = true;
            if (gameState.myPlayerId && gameState.players.has(gameState.myPlayerId)) {
                const player = gameState.players.get(gameState.myPlayerId);
                if (player.alive) { // Only update if player is still alive
                    player.keys = {...keys}; // Copy keys object
                }
            }
        }

        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
            if (gameState.myPlayerId && gameState.players.has(gameState.myPlayerId)) {
                const player = gameState.players.get(gameState.myPlayerId);
                if (player.alive) { // Only update if player is still alive
                    player.keys = {...keys}; // Copy keys object
                }
            }
        }

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (!gameState.gameRunning) return;
            
            // Update players
            gameState.players.forEach(player => {
                if (!player.alive) return;
                
                // AI movement
                if (player.isAI) {
                    updateAI(player);
                }
                
                // Movement - Increased base speed and power
                const baseSpeed = player.powerup === 'SPEED' ? 1.2 : 0.7; // Increased from 0.8/0.4
                const mass = player.radius / 15; // Mass factor based on size
                const speed = baseSpeed / Math.sqrt(mass); // Bigger players move slower but hit harder
                
                if (player.keys['w'] || player.keys['arrowup']) player.vy -= speed;
                if (player.keys['s'] || player.keys['arrowdown']) player.vy += speed;
                if (player.keys['a'] || player.keys['arrowleft']) player.vx -= speed;
                if (player.keys['d'] || player.keys['arrowright']) player.vx += speed;
                
                // Apply velocity
                player.x += player.vx;
                player.y += player.vy;
                
                // Reduced friction for more momentum
                player.vx *= 0.92; // Was 0.85
                player.vy *= 0.92;
                
                // Check ring boundaries with better elimination logic
                const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
                if (distFromCenter + player.radius > ringRadius) {
                    // Give player a chance to recover if just touching edge
                    if (distFromCenter + player.radius > ringRadius + 10) {
                        player.alive = false;
                        // Don't end game immediately, let the timer check handle it
                        console.log(`Player ${player.address.substring(0, 8)} eliminated! ${getAlivePlayers().length - 1} players remaining.`);
                    } else {
                        // Push back toward center with strong force
                        const pushAngle = Math.atan2(player.y - centerY, player.x - centerX);
                        player.vx -= Math.cos(pushAngle) * 2;
                        player.vy -= Math.sin(pushAngle) * 2;
                    }
                }
                
                // Check powerup expiration
                if (player.powerupEndTime && Date.now() > player.powerupEndTime) {
                    player.powerup = null;
                    player.powerupEndTime = 0;
                }

                // Actualizar rotaci√≥n basada en movimiento
                if (player.vx !== 0 || player.vy !== 0) {
                    // Calcular direcci√≥n de movimiento
                    player.rotation = Math.atan2(player.vy, player.vx);
                    // A√±adir variaci√≥n en la rotaci√≥n para efecto visual
                    player.rotationSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy) * 0.01;
                } else {
                    // Reducir velocidad de rotaci√≥n cuando est√° quieto
                    player.rotationSpeed *= 0.95;
                }
            });
            
            // Collision detection
            const playersArray = Array.from(gameState.players.values()).filter(p => p.alive);
            for (let i = 0; i < playersArray.length; i++) {
                for (let j = i + 1; j < playersArray.length; j++) {
                    checkCollision(playersArray[i], playersArray[j]);
                }
            }
            
            // Powerup collisions - fixing the collection logic
            for (let i = gameState.powerups.length - 1; i >= 0; i--) {
                const powerup = gameState.powerups[i];
                const playersArray = Array.from(gameState.players.values()).filter(p => p.alive);
                
                for (let j = 0; j < playersArray.length; j++) {
                    const player = playersArray[j];
                    const dist = Math.sqrt(Math.pow(player.x - powerup.x, 2) + Math.pow(player.y - powerup.y, 2));
                    
                    if (dist < player.radius + 15) {
                        // Collect powerup
                        player.powerup = powerup.type;
                        player.powerupEndTime = Date.now() + POWERUP_TYPES[powerup.type].duration;
                        
                        // Remove from array safely
                        gameState.powerups.splice(i, 1);
                        
                        // Show feedback
                        if (player.id === gameState.myPlayerId) {
                            showMessage(`Got ${powerup.type} powerup!`);
                        }
                        break; // Exit inner loop once powerup is collected
                    }
                }
            }
            
            // Spawn powerups randomly
            if (Math.random() < 0.01 && gameState.gamePhase === 'playing') {
                spawnPowerup();
            }
        }

        function updateAI(player) {
            // Simple AI: move toward center and avoid edges
            const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
            
            if (distFromCenter > ringRadius * 0.7) {
                // Move toward center
                const angle = Math.atan2(centerY - player.y, centerX - player.x);
                player.keys = {
                    w: Math.sin(angle) < -0.3,
                    s: Math.sin(angle) > 0.3,
                    a: Math.cos(angle) < -0.3,
                    d: Math.cos(angle) > 0.3
                };
            } else {
                // Random movement
                if (Math.random() < 0.1) {
                    player.keys = {
                        w: Math.random() < 0.25,
                        s: Math.random() < 0.25,
                        a: Math.random() < 0.25,
                        d: Math.random() < 0.25
                    };
                }
            }
        }

        function checkCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < p1.radius + p2.radius) {
                // Enhanced collision with better physics
                const mass1 = p1.radius * p1.radius; // Mass based on area
                const mass2 = p2.radius * p2.radius;
                
                // Strength multipliers
                const strength1 = (p1.powerup === 'STRENGTH' ? 2.0 : 1.0) * p1.bet * 150; // Increased from 100
                const strength2 = (p2.powerup === 'STRENGTH' ? 2.0 : 1.0) * p2.bet * 150;
                
                // Velocity-based momentum (players moving faster hit harder)
                const velocity1 = Math.sqrt(p1.vx * p1.vx + p1.vy * p1.vy);
                const velocity2 = Math.sqrt(p2.vx * p2.vx + p2.vy * p2.vy);
                const momentumFactor1 = 1 + velocity1 * 0.5;
                const momentumFactor2 = 1 + velocity2 * 0.5;
                
                // Normalize collision vector
                const nx = dx / dist;
                const ny = dy / dist;
                
                // Calculate impact forces with momentum
                const force1 = strength1 * momentumFactor1;
                const force2 = strength2 * momentumFactor2;
                
                // Apply forces with mass consideration
                const pushForce = 3.5; // Increased from 2
                p1.vx += nx * (force2 / mass1) * pushForce;
                p1.vy += ny * (force2 / mass1) * pushForce;
                p2.vx -= nx * (force1 / mass2) * pushForce;
                p2.vy -= ny * (force1 / mass2) * pushForce;
                
                // Separate players more aggressively
                const overlap = (p1.radius + p2.radius) - dist + 2; // Added +2 for better separation
                const separationForce = overlap * 0.6; // Increased from 0.5
                p1.x += nx * separationForce * (mass2 / (mass1 + mass2));
                p1.y += ny * separationForce * (mass2 / (mass1 + mass2));
                p2.x -= nx * separationForce * (mass1 / (mass1 + mass2));
                p2.y -= ny * separationForce * (mass1 / (mass1 + mass2));
                
                // Add screen shake effect for impact feedback
                if (p1.id === gameState.myPlayerId || p2.id === gameState.myPlayerId) {
                    shakeScreen();
                }
            }
        }

        // Add screen shake for impact feedback
        function shakeScreen() {
            canvas.style.transform = `translate(${Math.random() * 4 - 2}px, ${Math.random() * 4 - 2}px)`;
            setTimeout(() => {
                canvas.style.transform = 'translate(0, 0)';
            }, 100);
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ring
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw multiple danger zones for better visual feedback
            const dangerZones = [
                { radius: ringRadius - 20, color: '#ff6666', alpha: 0.3 },
                { radius: ringRadius - 40, color: '#ff4444', alpha: 0.2 },
                { radius: ringRadius - 60, color: '#ff2222', alpha: 0.1 }
            ];
            
            dangerZones.forEach(zone => {
                ctx.strokeStyle = zone.color;
                ctx.globalAlpha = zone.alpha;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, zone.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
            
            // Draw powerups
            gameState.powerups.forEach(powerup => {
                const type = POWERUP_TYPES[powerup.type];
                ctx.fillStyle = type.color;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw emoji
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.fillText(type.emoji, powerup.x, powerup.y + 7);
            });
            
            // Draw players with images instead of circles
            gameState.players.forEach(player => {
                if (!player.alive) return;
                
                // Show velocity trails for moving players
                const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                if (speed > 0.5) {
                    ctx.strokeStyle = player.color;
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = player.radius / 3;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(player.x - player.vx * 3, player.y - player.vy * 3);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
                
                // Seleccionar imagen seg√∫n el powerup
                let sumoImage = sumoImages.default;
                if (player.powerup === 'STRENGTH') {
                    sumoImage = sumoImages.strength;
                } else if (player.powerup === 'SPEED') {
                    sumoImage = sumoImages.speed;
                } else if (player.powerup === 'SHIELD') {
                    sumoImage = sumoImages.shield;
                }
                
                // Dibujar sombra para el efecto de glow
                ctx.shadowColor = player.color;
                ctx.shadowBlur = player.radius / 2;
                
                // Guardar contexto antes de rotar
                ctx.save();
                
                // Trasladar al centro del jugador
                ctx.translate(player.x, player.y);
                
                // Rotar seg√∫n la direcci√≥n de movimiento
                ctx.rotate(player.rotation);
                
                // Dibujar la imagen del sumo escalada seg√∫n el radio del jugador
                const size = player.radius * 2.2; // Un poco m√°s grande que el c√≠rculo original
                ctx.drawImage(sumoImage, -size/2, -size/2, size, size);
                
                // Restaurar contexto
                ctx.restore();
                ctx.shadowBlur = 0;
                
                // Si tiene escudo, dibujar c√≠rculo alrededor
                if (player.powerup === 'SHIELD') {
                    ctx.strokeStyle = '#4444ff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Show danger indicator when near edge
                const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
                if (distFromCenter + player.radius > ringRadius - 50) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Player bet amount
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText(player.bet.toFixed(3), player.x, player.y + player.radius + 15);
                ctx.fillText(player.bet.toFixed(3), player.x, player.y + player.radius + 15);
                
                // Powerup indicator
                if (player.powerup) {
                    const type = POWERUP_TYPES[player.powerup];
                    ctx.font = '16px Arial';
                    ctx.fillText(type.emoji, player.x, player.y - player.radius - 10);
                }
                
                // Player is you indicator
                if (player.id === gameState.myPlayerId) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Draw countdown
            if (gameState.gamePhase === 'countdown') {
                ctx.fillStyle = '#FFD700';
                ctx.font = '72px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.countdown || 'FIGHT!', centerX, centerY);
            }
        }

        function updateUI() {
            document.getElementById('prizePool').textContent = gameState.prizePool.toFixed(3);
            document.getElementById('playerCount').textContent = gameState.players.size;
            
            // Update timer
            if (gameState.gamePhase === 'countdown') {
                document.getElementById('gameTimer').textContent = gameState.countdown || 'FIGHT!';
            } else if (gameState.gamePhase === 'playing') {
                const alivePlayers = getAlivePlayers();
                document.getElementById('gameTimer').textContent = `${gameState.gameTime}s (${alivePlayers.length} alive)`;
            } else {
                document.getElementById('gameTimer').textContent = 'Waiting...';
            }
            
            // Update player list
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '';
            gameState.players.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.style.opacity = player.alive ? '1.0' : '0.5'; // Dim eliminated players
                card.innerHTML = `
                    <div style="color: ${player.color}">‚óè</div>
                    <div>${player.address.substring(0, 6)}...</div>
                    <div>${player.bet.toFixed(3)} FLOW</div>
                    <div>${player.alive ? 'üü¢' : 'üíÄ'}</div>
                `;
                playerList.appendChild(card);
            });
        }

        function getAlivePlayers() {
            return Array.from(gameState.players.values()).filter(p => p.alive);
        }

        // Update UI periodically
        setInterval(updateUI, 100);

        function spawnPowerup() {
            if (gameState.powerups.length < 3) {
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];
                
                // Spawn inside the ring but not too close to center
                const angle = Math.random() * Math.PI * 2;
                const minRadius = ringRadius * 0.2; // Minimum distance from center
                const maxRadius = ringRadius * 0.7; // Not too close to edge
                const distance = minRadius + Math.random() * (maxRadius - minRadius);
                
                gameState.powerups.push({
                    type: type,
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    rotation: 0
                });
            }
        }

        // Add a simple message display function
        function showMessage(text, duration = 2000) {
            const message = document.createElement('div');
            message.style.position = 'absolute';
            message.style.top = '20px';
            message.style.left = '50%';
            message.style.transform = 'translateX(-50%)';
            message.style.background = 'rgba(0,0,0,0.7)';
            message.style.color = 'white';
            message.style.padding = '10px 20px';
            message.style.borderRadius = '20px';
            message.style.fontWeight = 'bold';
            message.style.zIndex = '1000';
            message.textContent = text;
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.style.opacity = '0';
                message.style.transition = 'opacity 0.5s';
                setTimeout(() => document.body.removeChild(message), 500);
            }, duration);
        }
    </script>
</body>
</html>
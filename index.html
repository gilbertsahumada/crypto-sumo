<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Sumo - Fight for FLOW</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.5/ethers.umd.min.js" type="application/javascript"></script>
    <script src="./js/sumoContract.js"></script>
    <script src="./js/websocket-client.js"></script>
</head>
<body>
    <div class="game-container">
        <h1>
            <img src="./public/logo.png" alt="Crypto Sumo Logo" class="logo">
        </h1>
        
        <div class="game-info">
            <div class="wallet-info">
                <h3>üí∞ Wallet</h3>
                <p id="walletAddress">Not Connected</p>
                <div class="wallet-buttons">
                    <button class="btn" id="connectWallet">Connect Wallet</button>
                    <button class="btn" id="disconnectWallet" style="display:none; background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">Disconnect</button>
                </div>
                <p id="networkStatus" style="font-size: 12px; margin-top: 5px;"></p>
            </div>
            <div class="game-stats">
                <h3>üèÜ Game Stats</h3>
                <p>Prize Pool: <span id="prizePool">0</span> FLOW</p>
                <p>Players: <span id="playerCount">0</span></p>
                <p class="countdown" id="gameTimer"></p>
            </div>
        </div>
        
        <div class="controls">
            <input type="number" id="betAmount" placeholder="Bet (FLOW)" step="0.001" min="0.001" value="0.01" style="width: 120px;">
            <button class="btn" id="joinGame">Join Game</button>
            <button class="btn" id="startGame" style="display:none;">Start Game</button>
        </div>
        
        <div class="player-list" id="playerList"></div>
        
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <!-- 
        <div class="instructions">
            <h3>üéÆ How to Play</h3>
            <p><strong>WASD or Arrow Keys</strong> to move your sumo wrestler</p>
            <p>üí™ <strong>Bigger bet = Stronger wrestler</strong></p>
            <p>üéØ <strong>Push opponents out of the ring to win!</strong></p>
            <p>üöÄ <strong>Grab power-ups for temporary advantages</strong></p>
            <p>üèÜ <strong>Last player standing wins the entire prize pool!</strong></p>
        </div>
        -->
        
    </div>

    <script>
        // Flow Testnet Network Configuration
        const FLOW_TESTNET = {
            chainId: '0x221', // 545 in decimal
            chainName: 'Flow Testnet',
            rpcUrls: ['https://testnet.evm.nodes.onflow.org'],
            nativeCurrency: {
                name: 'FLOW',
                symbol: 'FLOW',
                decimals: 18
            },
            blockExplorerUrls: ['https://testnet.flowscan.org']
        };

        // Configuraci√≥n del juego (A√ëADIR ESTA SECCI√ìN)
        const GAME_CONFIG = {
            minPlayers: 1,     // Cambiar a 2 para el modo normal
            testMode: true,    // Activa caracter√≠sticas de prueba
            gameTime: 60       // Duraci√≥n de la partida en segundos
        };

        // Game State
        let gameState = {
            players: new Map(),
            powerups: [],
            gameRunning: false,
            gamePhase: 'waiting', // waiting, countdown, playing, finished
            prizePool: 0,
            myPlayerId: null,
            countdown: 0,
            gameTime: 60
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const ringRadius = 280;

        // Wallet connection
        let walletConnected = false;
        let walletAddress = '';

        // Game mechanics
        const POWERUP_TYPES = {
            STRENGTH: { emoji: 'üí™', color: '#ff4444', duration: 5000 },
            SPEED: { emoji: '‚ö°', color: '#44ff44', duration: 5000 },
            SHIELD: { emoji: 'üõ°Ô∏è', color: '#4444ff', duration: 3000 },
            MAGNET: { emoji: 'üß≤', color: '#ff44ff', duration: 4000 }
        };

        // Ethers.js variables para Ethereum
        let provider;
        let signer;

        // Precargar im√°genes de sumo
        const sumoImages = {
            default: new Image(),
            // MODIFICAR: Im√°genes espec√≠ficas de powerups como overlays
            strengthOverlay: new Image(),
            speedOverlay: new Image(),
            shieldOverlay: new Image(),
            magnetOverlay: new Image(), // Para cuando agregues la imagen
            // Im√°genes de personajes √∫nicos
            character1: new Image(),
            character2: new Image(),
            character3: new Image(),
            character4: new Image()
        };

        // A√ëADIR: Control de personajes asignados
        const assignedCharacters = new Set();
        let nextCharacterIndex = 1;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadSumoImages();
            setupEthers();
            setupEventListeners();
            
            // Iniciar conexi√≥n WebSocket
            gameConnection = new GameConnection();
            
            // Configurar callbacks de WebSocket
            gameConnection.setCallback('onConnect', () => {
                showMessage('Conectado al servidor del juego');
            });
            
            gameConnection.setCallback('onDisconnect', () => {
                showMessage('Desconectado del servidor del juego');
            });
            
            gameConnection.setCallback('onGameState', (newState) => {
                updateGameStateFromServer(newState);
            });
            
            gameConnection.setCallback('onError', (error) => {
                console.error('Error de conexi√≥n:', error);
                showMessage('Error de conexi√≥n con el servidor');
            });
            
            // Conectar al servidor
            gameConnection.connect();
            
            // Iniciar bucle de renderizado local
            gameLoop();
            
            // En modo offline, a√±adir jugadores demo
            setTimeout(() => {
                if (gameState.players.size === 0 && !gameConnection.connected) {
                    addDemoPlayers();
                }
            }, 2000);
        });

        // Cargar im√°genes de sumos
        function loadSumoImages() {
            // MODIFICAR: Cargar im√°genes espec√≠ficas de powerups como overlays
            sumoImages.default.src = './public/sumo-default.png';
            sumoImages.strengthOverlay.src = './public/sumo_strength.PNG';
            sumoImages.speedOverlay.src = './public/sumo_speed.PNG';
            sumoImages.shieldOverlay.src = './public/sumo_shield.PNG';
            // sumoImages.magnetOverlay.src = './public/sumo_magnet.PNG'; // Descomenta cuando tengas la imagen
            
            // MANTENER: Cargar im√°genes de personajes √∫nicos
            sumoImages.character1.src = './public/sumo_one.PNG';
            sumoImages.character2.src = './public/sumo_two.PNG';
            sumoImages.character3.src = './public/sumo_three.PNG';
            sumoImages.character4.src = './public/sumo_four.PNG';
            
            // A√±adir evento de carga para mostrar progreso
            let imagesLoaded = 0;
            const totalImages = Object.keys(sumoImages).length;
            
            Object.values(sumoImages).forEach(img => {
                img.onload = () => {
                    imagesLoaded++;
                    console.log(`Cargando im√°genes: ${imagesLoaded}/${totalImages}`);
                };
                
                img.onerror = (err) => {
                    console.error('Error cargando imagen:', err);
                };
            });
        }

        // Configuraci√≥n de ethers.js para interactuar con Ethereum
        function setupEthers() {
            try {
                // Verificar si MetaMask est√° instalado
                if (window.ethereum) {
                    // Crear provider usando el proveedor de la ventana (MetaMask) - Sintaxis Ethers v6
                    provider = new ethers.BrowserProvider(window.ethereum);
                    console.log("Ethers.js initialized with BrowserProvider (v6)");
                } else {
                    console.log("No Ethereum wallet detected"); // Este mensaje es correcto si no hay wallet
                }
            } catch (error) {
                console.error("Error setting up ethers:", error);
            }
        }

        function setupEventListeners() {
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
            document.getElementById('joinGame').addEventListener('click', joinGame);
            document.getElementById('startGame').addEventListener('click', startGame);
            
            // Keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        // Wallet functions con ethers.js
        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    alert("MetaMask or other Ethereum wallet not found! Please install MetaMask.");
                    simulateWalletConnection();
                    return;
                }
                
                // Request accounts first to ensure we're connected
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    alert("No accounts found or permission denied.");
                    simulateWalletConnection();
                    return;
                }
                
                // Show network status in UI
                document.getElementById('networkStatus').textContent = "Checking network...";
                
                // Check if we're on the correct network
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== FLOW_TESTNET.chainId) {
                    // Wrong network, prompt to switch
                    document.getElementById('networkStatus').textContent = "Switching to Flow Testnet...";
                    showMessage("Attempting to switch to Flow Testnet...");
                    
                    try {
                        const switched = await switchToFlowTestnet();
                        if (!switched) {
                            document.getElementById('networkStatus').textContent = "Please add Flow network manually";
                            showManualNetworkInstructions();
                            return;
                        }
                    } catch (switchError) {
                        console.error("Switch error:", switchError);
                        document.getElementById('networkStatus').textContent = "Network switch failed";
                        showManualNetworkInstructions();
                        return;
                    }
                }

                // Crear provider si no existe
                if (!provider) {
                    provider = new ethers.BrowserProvider(window.ethereum);
                }
                
                // Obtener el signer
                signer = await provider.getSigner();
                walletAddress = await signer.getAddress();
                walletConnected = true;
                
                // Actualizar UI
                document.getElementById('walletAddress').textContent = walletAddress.substring(0, 6) + '...' + walletAddress.substring(38);
                document.getElementById('connectWallet').style.display = 'none';
                document.getElementById('disconnectWallet').style.display = 'inline-block';
                document.getElementById('networkStatus').textContent = "Connected to Flow Testnet";
                
                // Configurar eventos para cambios en la wallet
                setupWalletEvents();
                
                // Obtener saldo
                const balance = await provider.getBalance(walletAddress);
                const etherBalance = ethers.formatEther(balance);
                
                console.log("Wallet connected:", walletAddress);
                console.log("Balance:", etherBalance, "FLOW");
                
                showMessage(`Wallet connected: ${etherBalance} FLOW`);
            } catch (error) {
                console.error("Error connecting wallet:", error);
                alert(`Error connecting wallet: ${error.message || error}`);
                document.getElementById('networkStatus').textContent = "Connection failed";
                simulateWalletConnection();
            }
        }
        
        // Function to disconnect wallet
        async function disconnectWallet() {
            try {
                // Reset wallet state
                walletConnected = false;
                walletAddress = '';
                signer = null;
                
                // Update UI
                document.getElementById('walletAddress').textContent = 'Not Connected';
                document.getElementById('connectWallet').style.display = 'inline-block';
                document.getElementById('disconnectWallet').style.display = 'none';
                document.getElementById('networkStatus').textContent = '';
                document.getElementById('joinGame').disabled = false;
                document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
                
                // Note: MetaMask doesn't have a direct disconnect method from dApps
                // We're just resetting our app's connection state
                
                showMessage('Wallet disconnected');
                
                // If player is in game, we may want to handle that
                if (gameState.myPlayerId) {
                    // This would depend on your game logic
                    // Possibly remove player or mark as disconnected
                }
                
            } catch (error) {
                console.error("Error disconnecting wallet:", error);
                showMessage('Error disconnecting wallet');
            }
        }
        
        // Function to display manual network adding instructions
        function showManualNetworkInstructions() {
            const instructions = document.createElement('div');
            instructions.style.position = 'fixed';
            instructions.style.top = '50%';
            instructions.style.left = '50%';
            instructions.style.transform = 'translate(-50%)';
            instructions.style.background = 'rgba(0,0,0,0.9)';
            instructions.style.color = 'white';
            instructions.style.padding = '20px';
            instructions.style.borderRadius = '10px';
            instructions.style.maxWidth = '400px';
            instructions.style.zIndex = '1001';
            instructions.innerHTML = `
                <h3 style="color: #FFD700;">Add Flow Network Manually</h3>
                <p>Please add Flow Testnet to your wallet with these details:</p>
                <ul style="text-align: left; margin: 15px 0;">
                    <li>Network Name: Flow Testnet</li>
                    <li>RPC URL: https://testnet.evm.nodes.onflow.org</li>
                    <li>Chain ID: 545 (0x221)</li>
                    <li>Currency Symbol: FLOW</li>
                    <li>Block Explorer: https://testnet.flowscan.org</li>
                </ul>
                <button id="closeInstructions" class="btn" style="margin-top: 10px;">Close</button>
                <button id="tryAgain" class="btn" style="margin-top: 10px; margin-left: 10px;">Try Again</button>
            `;
            
            document.body.appendChild(instructions);
            
            document.getElementById('closeInstructions').addEventListener('click', () => {
                document.body.removeChild(instructions);
            });
            
            document.getElementById('tryAgain').addEventListener('click', () => {
                document.body.removeChild(instructions);
                connectWallet();
            });
        }
        
        // Function to switch to Flow Testnet with improved error handling
        async function switchToFlowTestnet() {
            try {
                console.log("Attempting to switch to Flow Testnet, chainId:", FLOW_TESTNET.chainId);
                
                // First try to switch to the network
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: FLOW_TESTNET.chainId }],
                });
                console.log("Network switch successful");
                return true;
            } catch (switchError) {
                console.log("Switch error:", switchError);
                console.log("Switch error code:", switchError.code);
                
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902 || switchError.message.includes("wallet_addEthereumChain")) {
                    try {
                        console.log("Attempting to add Flow Testnet to wallet");
                        // Add the network to MetaMask
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: FLOW_TESTNET.chainId,
                                    chainName: FLOW_TESTNET.chainName,
                                    nativeCurrency: FLOW_TESTNET.nativeCurrency,
                                    rpcUrls: FLOW_TESTNET.rpcUrls,
                                    blockExplorerUrls: FLOW_TESTNET.blockExplorerUrls
                                }
                            ],
                        });
                        
                        // Verify the switch was successful
                        const newChainId = await window.ethereum.request({ method: 'eth_chainId' });
                        console.log("New chain ID after add:", newChainId);
                        return newChainId === FLOW_TESTNET.chainId;
                        
                    } catch (addError) {
                        console.error('Error adding Flow Testnet to wallet:', addError);
                        return false;
                    }
                }
                // Other errors
                console.error('Error switching to Flow Testnet:', switchError);
                return false;
            }
        }
        
        // Modificar setupWalletEvents para verificar la red en cambios de cadena
        function setupWalletEvents() {
            if (!window.ethereum) return;
            
            // Remover listeners anteriores para evitar duplicados
            try {
                window.ethereum.removeAllListeners('accountsChanged');
                window.ethereum.removeAllListeners('chainChanged');
            } catch (error) {
                console.log('No previous listeners to remove');
            }
            
            const handleAccountsChanged = async (accounts) => {
                console.log('Accounts changed:', accounts);
                if (accounts.length === 0) {
                    // Usuario desconect√≥ su wallet desde MetaMask
                    disconnectWallet(); // Use our disconnect function
                } else {
                    // Usuario cambi√≥ de cuenta
                    try {
                        walletAddress = accounts[0];
                        document.getElementById('walletAddress').textContent = walletAddress.substring(0, 6) + '...' + walletAddress.substring(38);
                        if (provider) {
                            signer = await provider.getSigner();
                        }
                        showMessage('Account changed');
                    } catch (error) {
                        console.error('Error handling account change:', error);
                    }
                }
            };
            
            const handleChainChanged = async (chainId) => {
                console.log('Chain changed to:', chainId);
                
                // Check if new chain is Flow Testnet
                if (chainId !== FLOW_TESTNET.chainId) {
                    document.getElementById('networkStatus').textContent = "Wrong network";
                    showMessage('Wrong network! Please switch to Flow Testnet', 5000);
                    document.getElementById('joinGame').disabled = true;
                    
                    // Add option to switch back
                    const switchButton = document.createElement('button');
                    switchButton.className = 'btn';
                    switchButton.textContent = 'Switch to Flow Testnet';
                    switchButton.style.margin = '10px auto';
                    switchButton.style.display = 'block';
                    
                    switchButton.onclick = async () => {
                        await switchToFlowTestnet();
                        document.body.removeChild(switchButton);
                    };
                    
                    document.body.appendChild(switchButton);
                } else {
                    document.getElementById('networkStatus').textContent = "Connected to Flow Testnet";
                    document.getElementById('joinGame').disabled = false;
                    showMessage('Connected to Flow Testnet ‚úì');
                }
            };
            
            // Usar try-catch para manejar diferentes versiones de MetaMask
            try {
                if (window.ethereum.on) {
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);
                } else if (window.ethereum.addEventListener) {
                    window.ethereum.addEventListener('accountsChanged', handleAccountsChanged);
                    window.ethereum.addEventListener('chainChanged', handleChainChanged);
                } else {
                    console.log('MetaMask event listeners not supported');
                }
            } catch (error) {
                console.error('Error setting up wallet events:', error);
                // Continuar sin event listeners si hay problemas
            }
        }

        // Game functions - Modificar joinGame para usar ethers.js
        async function joinGame() {
            if (!walletConnected) {
                alert('Please connect your wallet first!');
                return;
            }

            try {
                // Verificar red correcta
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== FLOW_TESTNET.chainId) {
                    alert('Please switch to Flow Testnet to play!');
                    const switched = await switchToFlowTestnet();
                    if (!switched) {
                        showManualNetworkInstructions();
                        return;
                    }
                }

                const betAmount = parseFloat(document.getElementById('betAmount').value);
                if (betAmount < 0.001) {
                    alert('Minimum bet is 0.001 FLOW');
                    return;
                }
                
                // Si estamos en modo demo o no hay conexi√≥n al servidor
                if (!signer || !gameConnection.connected) {
                    simulateJoinGame(betAmount);
                    return;
                }

                // Mostrar que estamos procesando
                document.getElementById('joinGame').disabled = true;
                document.getElementById('joinGame').textContent = 'Processing...';
                
                // Obtener saldo para verificar
                const balance = await provider.getBalance(walletAddress);
                const betAmountWei = ethers.parseEther(betAmount.toString());
                
                // Verificar que tiene suficiente saldo
                if (balance < betAmountWei) {
                    alert(`Insufficient balance. You have ${ethers.formatEther(balance)} FLOW.`);
                    document.getElementById('joinGame').disabled = false;
                    document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
                    return;
                }
                
                // Procesar transacci√≥n igual que antes
                const targetAddress = "0xb322E239E5A32724633A595b8f8657F9cbb307B2";
                
                try {
                    showMessage(`Processing ${betAmount} FLOW bet...`, 1500);
                    
                    const tx = await signer.sendTransaction({
                        to: targetAddress,
                        value: betAmountWei,
                        gasLimit: 100000
                    });
                    
                    console.log("Transaction sent:", tx.hash);
                    showMessage(`Transaction pending... Please wait.`);
                    
                    const receipt = await tx.wait();
                    console.log("Transaction confirmed:", receipt);
                    
                    // Unirse al juego a trav√©s de WebSocket
                    gameConnection.joinGame(betAmount, walletAddress);
                    
                    showMessage(`Bet of ${betAmount} FLOW confirmed! üéâ`);
                    document.getElementById('joinGame').textContent = 'Joined ‚úì';
                } catch (txError) {
                    console.error("Transaction error:", txError);
                    alert(`Transaction failed: ${txError.message}`);
                    document.getElementById('joinGame').disabled = false;
                    document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
                }
            } catch (error) {
                console.error("Error placing bet:", error);
                alert(`Error placing bet: ${error.message}`);
                document.getElementById('joinGame').disabled = false;
                document.getElementById('joinGame').textContent = 'Join Game (Bet FLOW)';
            }
        }
        
        // Simular unirse al juego (para demo)
        function simulateJoinGame(betAmount) {
            document.getElementById('joinGame').disabled = true;
            document.getElementById('joinGame').textContent = 'Processing...';
            
            setTimeout(() => {
                createPlayer(betAmount);
                
                // Mensaje de confirmaci√≥n
                showMessage(`Bet of ${betAmount} FLOW confirmed! üéâ`);
                document.getElementById('joinGame').textContent = 'Joined ‚úì';
            }, 1500);
        }
        
        // A√ëADIR: Funci√≥n para asignar personaje √∫nico
        function getNextAvailableCharacter() {
            // Buscar el siguiente personaje disponible
            for (let i = 1; i <= 4; i++) {
                if (!assignedCharacters.has(i)) {
                    assignedCharacters.add(i);
                    return i;
                }
            }
            
            // Si todos est√°n ocupados, reciclar desde el primero
            const characterIndex = ((nextCharacterIndex - 1) % 4) + 1;
            nextCharacterIndex++;
            return characterIndex;
        }

        // A√ëADIR: Funci√≥n para liberar personaje
        function releaseCharacter(characterIndex) {
            assignedCharacters.delete(characterIndex);
        }

        // A√ëADIR: Funci√≥n para calcular tama√±o del jugador
        function calculatePlayerSize(bet) {
            // Tama√±o base m√≠nimo
            const minSize = 20;
            // Tama√±o m√°ximo para evitar que se compriman demasiado
            const maxSize = 50;
            // Factor de escala: cada 0.01 FLOW a√±ade ~10 unidades de radio
            const scaleFactor = 1000;
            
            const calculatedSize = minSize + (bet * scaleFactor);
            return Math.max(minSize, Math.min(maxSize, calculatedSize));
        }

        // MODIFICAR: Funci√≥n para crear jugador con tama√±o proporcional
        function createPlayer(betAmount) {
            const playerId = walletAddress;
            gameState.myPlayerId = playerId;
            
            // Asignar personaje √∫nico
            const characterIndex = getNextAvailableCharacter();
            
            const player = {
                id: playerId,
                address: walletAddress,
                bet: betAmount,
                x: centerX + (Math.random() - 0.5) * 200,
                y: centerY + (Math.random() - 0.5) * 200,
                vx: 0,
                vy: 0,
                radius: calculatePlayerSize(betAmount), // Usar nueva funci√≥n de c√°lculo
                color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                alive: true,
                powerup: null,
                powerupEndTime: 0,
                keys: {},
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: 0,
                // A√ëADIR: √çndice de personaje
                characterIndex: characterIndex
            };

            gameState.players.set(playerId, player);
            gameState.prizePool += betAmount;
            
            console.log(`Jugador ${playerId} asignado al personaje ${characterIndex}, tama√±o: ${player.radius}`);
            
            updateUI();
            
            if (gameState.players.size >= GAME_CONFIG.minPlayers) {
                document.getElementById('startGame').style.display = 'inline-block';
                if (GAME_CONFIG.testMode && gameState.players.size === 1) {
                    document.getElementById('startGame').textContent = 'Start Game (Test Mode)';
                } else {
                    document.getElementById('startGame').textContent = 'Start Game';
                }
            }
        }

        // Funci√≥n simulaci√≥n sigue siendo √∫til para pruebas
        function simulateWalletConnection() {
            walletAddress = '0x' + Math.random().toString(16).substring(2, 42);
            walletConnected = true;
            document.getElementById('walletAddress').textContent = walletAddress.substring(0, 6) + '...' + walletAddress.substring(38);
            document.getElementById('connectWallet').textContent = 'Connected ‚úì';
            document.getElementById('connectWallet').disabled = true;
        }

        // Game functions
        function startGame() {
            // Verificar si hay suficientes jugadores seg√∫n la configuraci√≥n
            if (gameState.players.size < GAME_CONFIG.minPlayers) {
                alert(`Necesitas al menos ${GAME_CONFIG.minPlayers} jugador(es) para comenzar!`);
                return;
            }
            
            // Mostrar mensaje cuando se inicia en modo de prueba con 1 jugador
            if (GAME_CONFIG.testMode && gameState.players.size === 1) {
                showMessage('‚ö†Ô∏è Iniciando en modo prueba con 1 jugador', 3000);
            }
            
            // Si tenemos conexi√≥n al servidor, enviamos la se√±al al servidor
            if (gameConnection.connected) {
                gameConnection.startGame();
            } else {
                // Modo offline (como estaba antes)
                gameState.gamePhase = 'countdown';
                gameState.countdown = 3;
                document.getElementById('startGame').style.display = 'none';
                
                const countdownInterval = setInterval(() => {
                    gameState.countdown--;
                    if (gameState.countdown <= 0) {
                        clearInterval(countdownInterval);
                        gameState.gamePhase = 'playing';
                        gameState.gameRunning = true;
                        startGameTimer();
                        spawnPowerup();
                    }
                }, 1000);
            }
        }

        function startGameTimer() {
            gameState.gameTime = 60;
            const timer = setInterval(() => {
                gameState.gameTime--;
                updateUI(); // Ensure UI updates during game
                
                const alivePlayers = getAlivePlayers();
                
                // MODIFICAR: Simplificar l√≥gica - terminar si queda 1 o menos jugadores
                let shouldEndGame = false;
                
                if (alivePlayers.length <= 1) {
                    shouldEndGame = true;
                    if (alivePlayers.length === 1) {
                        console.log(`Fin del juego: Ganador encontrado - ${alivePlayers[0].address.substring(0, 8)}...`);
                    } else {
                        console.log('Fin del juego: No quedan jugadores vivos');
                    }
                } else if (gameState.gameTime <= 0) {
                    shouldEndGame = true;
                    console.log('Fin del juego: Tiempo agotado');
                }
                
                if (shouldEndGame) {
                    clearInterval(timer);
                    endGame();
                }
            }, 1000);
        }

        // MODIFICAR: Simplificar funci√≥n endGame
        function endGame() {
            gameState.gameRunning = false;
            gameState.gamePhase = 'finished';
            
            const alivePlayers = getAlivePlayers();
            
            // L√≥gica unificada para todos los modos
            if (alivePlayers.length === 1) {
                const winner = alivePlayers[0];
                setTimeout(() => {
                    if (GAME_CONFIG.testMode) {
                        alert(`üéØ Test completed! Player ${winner.address.substring(0, 8)}... survived and wins ${gameState.prizePool.toFixed(3)} FLOW!`);
                    } else {
                        alert(`üèÜ Winner: ${winner.address.substring(0, 8)}... wins ${gameState.prizePool.toFixed(3)} FLOW!`);
                    }
                    resetGame();
                }, 500);
            } else if (alivePlayers.length === 0) {
                setTimeout(() => {
                    if (GAME_CONFIG.testMode) {
                        alert('üí• Test failed! All players were eliminated. Try again!');
                    } else {
                        alert('üí• All players eliminated! No winner this round.');
                    }
                    resetGame();
                }, 500);
            } else {
                // Solo si el tiempo se agot√≥ con m√∫ltiples jugadores vivos
                setTimeout(() => {
                    if (GAME_CONFIG.testMode) {
                        alert('üïê Time up! Test completed - multiple survivors!');
                    } else {
                        alert('üïê Time up! No clear winner this round.');
                    }
                    resetGame();
                }, 500);
            }
        }

        // MODIFICAR: Limpiar personajes asignados al resetear el juego
        function resetGame() {
            // Liberar todos los personajes asignados
            assignedCharacters.clear();
            nextCharacterIndex = 1;
            
            // Reset game state for a new round
            gameState = {
                players: new Map(),
                powerups: [],
                gameRunning: false,
                gamePhase: 'waiting',
                prizePool: 0,
                myPlayerId: null,
                countdown: 0,
                gameTime: 60
            };
            
            // Re-enable UI controls
            document.getElementById('joinGame').disabled = false;
            document.getElementById('startGame').style.display = 'none';
            document.getElementById('connectWallet').disabled = walletConnected;
            
            // Clear player input state
            Object.keys(keys).forEach(key => keys[key] = false);
            
            updateUI();
            
            // Add demo players again for testing
            setTimeout(() => {
                if (gameState.players.size === 0) {
                    addDemoPlayers();
                }
            }, 1000);
        }

        // MODIFICAR: Funci√≥n para agregar jugadores demo con tama√±os variados
        function addDemoPlayers() {
            // Add some AI players for demo with varied bet amounts
            const demoPlayers = [
                { bet: 0.005, color: '#ff6b6b' },   // Peque√±o
                { bet: 0.025, color: '#4ecdc4' },   // Grande
                { bet: 0.015, color: '#45b7d1' }    // Mediano
            ];
            
            demoPlayers.forEach((demo, i) => {
                const playerId = `demo_${i}`;
                const characterIndex = getNextAvailableCharacter();
                
                const player = {
                    id: playerId,
                    address: '0x' + Math.random().toString(16).substring(2, 42),
                    bet: demo.bet,
                    x: centerX + (Math.random() - 0.5) * 200,
                    y: centerY + (Math.random() - 0.5) * 200,
                    vx: 0,
                    vy: 0,
                    radius: calculatePlayerSize(demo.bet), // Usar nueva funci√≥n de c√°lculo
                    color: demo.color,
                    alive: true,
                    powerup: null,
                    powerupEndTime: 0,
                    keys: {},
                    isAI: true,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: 0,
                    // A√ëADIR: √çndice de personaje
                    characterIndex: characterIndex
                };
                
                gameState.players.set(playerId, player);
                gameState.prizePool += demo.bet;
                
                console.log(`Demo player ${playerId} asignado al personaje ${characterIndex}, tama√±o: ${player.radius}`);
            });
            
            updateUI();
        }

        // Input handling
        const keys = {};
        function handleKeyDown(e) {
            // MODIFICAR: Permitir input tanto en juego como en sala de espera
            if (!gameState.gameRunning && gameState.gamePhase !== 'waiting') return;

            // Prevent scrolling with arrow keys
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
            
            keys[e.key.toLowerCase()] = true;
            
            // Enviar al servidor si estamos conectados
            if (gameConnection.connected && gameState.myPlayerId) {
                gameConnection.sendPlayerInput(keys);
            }
            
            // Actualizaci√≥n local para mejor responsividad
            if (gameState.myPlayerId && gameState.players.has(gameState.myPlayerId)) {
                const player = gameState.players.get(gameState.myPlayerId);
                if (player.alive) {
                    player.keys = {...keys};
                }
            }
        }

        function handleKeyUp(e) {
            // MODIFICAR: Permitir input tanto en juego como en sala de espera
            if (!gameState.gameRunning && gameState.gamePhase !== 'waiting') return;

            // Prevent scrolling with arrow keys (also on keyup for completeness, though keydown is primary)
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
            
            keys[e.key.toLowerCase()] = false;
            
            // Enviar al servidor si estamos conectados
            if (gameConnection.connected && gameState.myPlayerId) {
                gameConnection.sendPlayerInput(keys);
            }
            
            // Actualizaci√≥n local para mejor responsividad
            if (gameState.myPlayerId && gameState.players.has(gameState.myPlayerId)) {
                const player = gameState.players.get(gameState.myPlayerId);
                if (player.alive) {
                    player.keys = {...keys};
                }
            }
        }

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Si el juego est√° en modo online, no actualizamos la f√≠sica localmente
            // Solo el servidor calcula la f√≠sica y nos env√≠a las actualizaciones
            if (gameConnection.connected && (gameState.gameRunning || gameState.gamePhase === 'waiting')) {
                // MODIFICAR: Aplicar predicci√≥n tanto en juego como en sala de espera
                if (gameState.myPlayerId && gameState.players.has(gameState.myPlayerId)) {
                    const player = gameState.players.get(gameState.myPlayerId);
                    if (player.alive) {
                        // Aplicar inputs locales (predicci√≥n cliente)
                        if (gameState.gamePhase === 'waiting') {
                            applyWaitingRoomInput(player);
                        } else {
                            applyPlayerInput(player);
                        }
                    }
                }
                return;
            }
            
            // A√ëADIR: Modo offline para sala de espera
            if (gameState.gamePhase === 'waiting') {
                updateWaitingRoomOffline();
                return;
            }
            
            // Modo offline: actualizar todo localmente como antes
            if (!gameState.gameRunning) return;
            
            // Update players
            gameState.players.forEach(player => {
                if (!player.alive) return;
                
                // AI movement
                if (player.isAI) {
                    updateAI(player);
                }
                
                // MODIFICAR: Movimiento ajustado por tama√±o del jugador
                const baseSpeed = player.powerup === 'SPEED' ? 1.2 : 0.7;
                // Factor de masa m√°s realista: jugadores m√°s grandes son m√°s lentos pero m√°s fuertes
                const mass = Math.pow(player.radius / 20, 1.5); // M√°s gradual que el anterior
                const speed = baseSpeed / Math.sqrt(mass);
                
                if (player.keys['w'] || player.keys['arrowup']) player.vy -= speed;
                if (player.keys['s'] || player.keys['arrowdown']) player.vy += speed;
                if (player.keys['a'] || player.keys['arrowleft']) player.vx -= speed;
                if (player.keys['d'] || player.keys['arrowright']) player.vx += speed;
                
                // Apply velocity
                player.x += player.vx;
                player.y += player.vy;
                
                // Reduced friction for more momentum
                player.vx *= 0.92; // Was 0.85
                player.vy *= 0.92;
                
                // Check ring boundaries with better elimination logic
                const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
                if (distFromCenter + player.radius > ringRadius) {
                    // Give player a chance to recover if just touching edge
                    if (distFromCenter + player.radius > ringRadius + 10) {
                        player.alive = false;
                        // MODIFICAR: Mejorar mensaje de eliminaci√≥n
                        const remainingAlive = getAlivePlayers().length - 1; // -1 porque este jugador a√∫n cuenta como vivo en el array
                        console.log(`Player ${player.address.substring(0, 8)} eliminated! ${remainingAlive} players remaining.`);
                        
                        // A√ëADIR: Verificar inmediatamente si el juego debe terminar
                        if (remainingAlive <= 1) {
                            console.log('Verificaci√≥n inmediata: Juego debe terminar por eliminaci√≥n');
                            // Peque√±o delay para que la eliminaci√≥n se procese visualmente
                            setTimeout(() => {
                                if (gameState.gameRunning) { // Solo si el juego a√∫n est√° corriendo
                                    endGame();
                                }
                            }, 100);
                        }
                    } else {
                        // Push back toward center with strong force
                        const pushAngle = Math.atan2(player.y - centerY, player.x - centerX);
                        player.vx -= Math.cos(pushAngle) * 2;
                        player.vy -= Math.sin(pushAngle) * 2;
                    }
                }
                
                // Check powerup expiration
                if (player.powerupEndTime && Date.now() > player.powerupEndTime) {
                    player.powerup = null;
                    player.powerupEndTime = 0;
                }

                // Actualizar rotaci√≥n basada en movimiento
                if (player.vx !== 0 || player.vy !== 0) {
                    // Calcular direcci√≥n de movimiento
                    player.rotation = Math.atan2(player.vy, player.vx);
                    // A√±adir variaci√≥n en la rotaci√≥n para efecto visual
                    player.rotationSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy) * 0.01;
                } else {
                    // Reducir velocidad de rotaci√≥n cuando est√° quieto
                    player.rotationSpeed *= 0.95;
                }
            });
            
            // Collision detection
            const playersArray = Array.from(gameState.players.values()).filter(p => p.alive);
            for (let i = 0; i < playersArray.length; i++) {
                for (let j = i + 1; j < playersArray.length; j++) {
                    checkCollision(playersArray[i], playersArray[j]);
                }
            }
            
            // Powerup collisions - fixing the collection logic
            for (let i = gameState.powerups.length - 1; i >= 0; i--) {
                const powerup = gameState.powerups[i];
                const playersArray = Array.from(gameState.players.values()).filter(p => p.alive);
                
                for (let j = 0; j < playersArray.length; j++) {
                    const player = playersArray[j];
                    const dist = Math.sqrt(Math.pow(player.x - powerup.x, 2) + Math.pow(player.y - powerup.y, 2));
                    
                    if (dist < player.radius + 15) {
                        // Collect powerup
                        player.powerup = powerup.type;
                        player.powerupEndTime = Date.now() + POWERUP_TYPES[powerup.type].duration;
                        
                        // Remove from array safely
                        gameState.powerups.splice(i, 1);
                        
                        // Show feedback
                        if (player.id === gameState.myPlayerId) {
                            showMessage(`Got ${powerup.type} powerup!`);
                        }
                        break; // Exit inner loop once powerup is collected
                    }
                }
            }
            
            // Spawn powerups randomly
            if (Math.random() < 0.01 && gameState.gamePhase === 'playing') {
                spawnPowerup();
            }
        }

        // Nueva funci√≥n para aplicar inputs de jugador (predicci√≥n cliente)
        function applyPlayerInput(player) {
            // Movimiento basado en las teclas presionadas
            const baseSpeed = player.powerup === 'SPEED' ? 1.2 : 0.7;
            // MODIFICAR: Factor de masa m√°s realista basado en el tama√±o
            const mass = Math.pow(player.radius / 20, 1.5); // M√°s gradual
            const speed = baseSpeed / Math.sqrt(mass);
            
            if (player.keys['w'] || player.keys['arrowup']) player.vy -= speed * 0.5;
            if (player.keys['s'] || player.keys['arrowdown']) player.vy += speed * 0.5;
            if (player.keys['a'] || player.keys['arrowleft']) player.vx -= speed * 0.5;
            if (player.keys['d'] || player.keys['arrowright']) player.vx += speed * 0.5;
            
            // Aplicar velocidad (solo una fracci√≥n para evitar desincronizaci√≥n)
            player.x += player.vx * 0.5;
            player.y += player.vy * 0.5;
        }

        // A√ëADIR: Funci√≥n para aplicar inputs en sala de espera
        function applyWaitingRoomInput(player) {
            const baseSpeed = 0.4; // Velocidad reducida
            // MODIFICAR: Factor de masa m√°s realista
            const mass = Math.pow(player.radius / 20, 1.5);
            const speed = baseSpeed / Math.sqrt(mass);
            
            if (player.keys['w'] || player.keys['arrowup']) player.vy -= speed * 0.3;
            if (player.keys['s'] || player.keys['arrowdown']) player.vy += speed * 0.3;
            if (player.keys['a'] || player.keys['arrowleft']) player.vx -= speed * 0.3;
            if (player.keys['d'] || player.keys['arrowright']) player.vx += speed * 0.3;
            
            // Aplicar velocidad (predicci√≥n suave)
            player.x += player.vx * 0.3;
            player.y += player.vy * 0.3;
        }

        function updateAI(player) {
            // Simple AI: move toward center and avoid edges
            const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
            
            if (distFromCenter > ringRadius * 0.7) {
                // Move toward center
                const angle = Math.atan2(centerY - player.y, centerX - player.x);
                player.keys = {
                    w: Math.sin(angle) < -0.3,
                    s: Math.sin(angle) > 0.3,
                    a: Math.cos(angle) < -0.3,
                    d: Math.cos(angle) > 0.3
                };
            } else {
                // Random movement
                if (Math.random() < 0.1) {
                    player.keys = {
                        w: Math.random() < 0.25,
                        s: Math.random() < 0.25,
                        a: Math.random() < 0.25,
                        d: Math.random() < 0.25
                    };
                }
            }
        }

        // A√ëADIR: Actualizaci√≥n de sala de espera en modo offline
        function updateWaitingRoomOffline() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const ringRadius = 280;
            
            // Actualizar jugadores en sala de espera
            gameState.players.forEach(player => {
                if (!player.alive) return;
                
                // AI movement (si aplica)
                if (player.isAI) {
                    updateAIWaitingRoom(player);
                }
                
                // MODIFICAR: Movimiento ajustado por tama√±o en sala de espera
                const baseSpeed = 0.4;
                const mass = Math.pow(player.radius / 20, 1.5);
                const speed = baseSpeed / Math.sqrt(mass);
                
                if (player.keys['w'] || player.keys['arrowup']) player.vy -= speed;
                if (player.keys['s'] || player.keys['arrowdown']) player.vy += speed;
                if (player.keys['a'] || player.keys['arrowleft']) player.vx -= speed;
                if (player.keys['d'] || player.keys['arrowright']) player.vx += speed;
                
                // Aplicar velocidad
                player.x += player.vx;
                player.y += player.vy;
                
                // Fricci√≥n aumentada
                player.vx *= 0.85;
                player.vy *= 0.85;
                
                // Mantener dentro del ring con rebote suave
                const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
                if (distFromCenter + player.radius > ringRadius) {
                    const pushAngle = Math.atan2(player.y - centerY, player.x - centerX);
                    player.vx -= Math.cos(pushAngle) * 1.5;
                    player.vy -= Math.sin(pushAngle) * 1.5;
                    
                    if (distFromCenter + player.radius > ringRadius + 20) {
                        const newDist = ringRadius - player.radius - 10;
                        player.x = centerX + Math.cos(pushAngle) * newDist;
                        player.y = centerY + Math.sin(pushAngle) * newDist;
                    }
                }
                
                // Actualizar rotaci√≥n
                if (player.vx !== 0 || player.vy !== 0) {
                    player.rotation = Math.atan2(player.vy, player.vx);
                    player.rotationSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy) * 0.01;
                } else {
                    player.rotationSpeed *= 0.95;
                }
            });
            
            // Colisiones suaves entre jugadores
            const playersArray = Array.from(gameState.players.values()).filter(p => p.alive);
            for (let i = 0; i < playersArray.length; i++) {
                for (let j = i + 1; j < playersArray.length; j++) {
                    checkWaitingRoomCollisionOffline(playersArray[i], playersArray[j]);
                }
            }
        }

        // A√ëADIR: AI simplificado para sala de espera
        function updateAIWaitingRoom(player) {
            // Movimiento m√°s calmado en sala de espera
            if (Math.random() < 0.05) { // Menos frecuente
                player.keys = {
                    w: Math.random() < 0.15,
                    s: Math.random() < 0.15,
                    a: Math.random() < 0.15,
                    d: Math.random() < 0.15
                };
            }
        }

        function checkCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < p1.radius + p2.radius) {
                // MODIFICAR: Masa m√°s realista basada en el √°rea del c√≠rculo
                const mass1 = Math.PI * p1.radius * p1.radius; // √Årea real del c√≠rculo
                const mass2 = Math.PI * p2.radius * p2.radius;
                
                // MODIFICAR: Fuerza basada en la apuesta y el tama√±o
                const strength1 = (p1.powerup === 'STRENGTH' ? 2.0 : 1.0) * p1.bet * 200; // Aumentado
                const strength2 = (p2.powerup === 'STRENGTH' ? 2.0 : 1.0) * p2.bet * 200;
                
                // Velocity-based momentum (players moving faster hit harder)
                const velocity1 = Math.sqrt(p1.vx * p1.vx + p1.vy * p1.vy);
                const velocity2 = Math.sqrt(p2.vx * p2.vx + p2.vy * p2.vy);
                const momentumFactor1 = 1 + velocity1 * 0.5;
                const momentumFactor2 = 1 + velocity2 * 0.5;
                
                // Normalize collision vector
                const nx = dx / dist;
                const ny = dy / dist;
                
                // Calculate impact forces with momentum
                const force1 = strength1 * momentumFactor1;
                const force2 = strength2 * momentumFactor2;
                
                // Apply forces with mass consideration
                const pushForce = 4.0; // Aumentado para hacer las colisiones m√°s impactantes
                p1.vx += nx * (force2 / mass1) * pushForce;
                p1.vy += ny * (force2 / mass1) * pushForce;
                p2.vx -= nx * (force1 / mass2) * pushForce;
                p2.vy -= ny * (force1 / mass2) * pushForce;
                
                // Separate players more aggressively
                const overlap = (p1.radius + p2.radius) - dist + 2;
                const separationForce = overlap * 0.6;
                p1.x += nx * separationForce * (mass2 / (mass1 + mass2));
                p1.y += ny * separationForce * (mass2 / (mass1 + mass2));
                p2.x -= nx * separationForce * (mass1 / (mass1 + mass2));
                p2.y -= ny * separationForce * (mass1 / (mass1 + mass2));
                
                // Add screen shake effect for impact feedback
                if (p1.id === gameState.myPlayerId || p2.id === gameState.myPlayerId) {
                    shakeScreen();
                }
            }
        }

        // A√ëADIR: Colisiones suaves para sala de espera (modo offline)
        function checkWaitingRoomCollisionOffline(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < p1.radius + p2.radius) {
                const nx = dx / dist;
                const ny = dy / dist;
                
                // Separaci√≥n suave
                const overlap = (p1.radius + p2.radius) - dist + 1;
                const separationForce = overlap * 0.3;
                
                p1.x += nx * separationForce * 0.5;
                p1.y += ny * separationForce * 0.5;
                p2.x -= nx * separationForce * 0.5;
                p2.y -= ny * separationForce * 0.5;
                
                // Reducir velocidad
                p1.vx *= 0.7;
                p1.vy *= 0.7;
                p2.vx *= 0.7;
                p2.vy *= 0.7;
            }
        }

        // Add screen shake for impact feedback
        function shakeScreen() {
            canvas.style.transform = `translate(${Math.random() * 4 - 2}px, ${Math.random() * 4 - 2}px)`;
            setTimeout(() => {
                canvas.style.transform = 'translate(0, 0)';
            }, 100);
        }

        // MODIFICAR: Funci√≥n de renderizado para usar im√°genes base + overlays de powerups
        function render() {
            // Clear canvas
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ring
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw multiple danger zones for better visual feedback
            const dangerZones = [
                { radius: ringRadius - 20, color: '#ff6666', alpha: 0.3 },
                { radius: ringRadius - 40, color: '#ff4444', alpha: 0.2 },
                { radius: ringRadius - 60, color: '#ff2222', alpha: 0.1 }
            ];
            
            dangerZones.forEach(zone => {
                ctx.strokeStyle = zone.color;
                ctx.globalAlpha = zone.alpha;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.arc(centerX, centerY, zone.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
            
            // Draw powerups
            gameState.powerups.forEach(powerup => {
                const type = POWERUP_TYPES[powerup.type];
                ctx.fillStyle = type.color;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw emoji
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.fillText(type.emoji, powerup.x, powerup.y + 7);
            });
            
            // Draw players with base images + powerup overlays
            gameState.players.forEach(player => {
                if (!player.alive) return;
                
                // Show velocity trails for moving players
                const speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                if (speed > 0.5) {
                    ctx.strokeStyle = player.color;
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = player.radius / 3;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(player.x - player.vx * 3, player.y - player.vy * 3);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
                
                // NUEVO: Siempre usar la imagen base del personaje
                let baseImage = sumoImages[`character${player.characterIndex}`] || sumoImages.character1;
                
                // Asegurar que la imagen existe, si no usar default
                if (!baseImage || !baseImage.complete) {
                    baseImage = sumoImages.character1;
                }
                
                // NUEVO: Determinar imagen overlay de powerup si existe
                let overlayImage = null;
                if (player.powerup) {
                    switch (player.powerup) {
                        case 'STRENGTH':
                            overlayImage = sumoImages.strengthOverlay;
                            break;
                        case 'SPEED':
                            overlayImage = sumoImages.speedOverlay;
                            break;
                        case 'SHIELD':
                            overlayImage = sumoImages.shieldOverlay;
                            break;
                        case 'MAGNET':
                            overlayImage = sumoImages.magnetOverlay;
                            break;
                    }
                }
                
                // MODIFICAR: Efectos visuales mejorados para powerups
                let glowIntensity = player.radius / 2;
                let glowColor = player.color;
                
                if (player.powerup) {
                    glowIntensity = player.radius * 1.2;
                    switch (player.powerup) {
                        case 'STRENGTH':
                            glowColor = '#ff4444';
                            break;
                        case 'SPEED':
                            glowColor = '#44ff44';
                            break;
                        case 'SHIELD':
                            glowColor = '#4444ff';
                            break;
                        case 'MAGNET':
                            glowColor = '#ff44ff';
                            break;
                        default:
                            glowColor = player.color;
                    }
                }
                
                // Dibujar sombra/glow
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = glowIntensity;
                
                // Guardar contexto antes de rotar
                ctx.save();
                
                // Trasladar al centro del jugador
                ctx.translate(player.x, player.y);
                
                // Rotar seg√∫n la direcci√≥n de movimiento
                ctx.rotate(player.rotation);
                
                // A√ëADIR: Efecto de pulsaci√≥n para powerups
                let sizeMultiplier = 2.2;
                if (player.powerup) {
                    // Crear efecto de pulsaci√≥n basado en el tiempo
                    const pulseTime = Date.now() * 0.005;
                    sizeMultiplier = 2.2 + Math.sin(pulseTime) * 0.1;
                }
                
                // NUEVO: Dibujar la imagen base del personaje SIEMPRE
                const size = player.radius * sizeMultiplier;
                ctx.drawImage(baseImage, -size/2, -size/2, size, size);
                
                // NUEVO: Dibujar overlay de powerup si existe y est√° cargado
                if (overlayImage && overlayImage.complete) {
                    // Ajustar opacidad del overlay para efecto de mezcla
                    ctx.globalAlpha = 0.7;
                    ctx.drawImage(overlayImage, -size/2, -size/2, size, size);
                    ctx.globalAlpha = 1.0;
                }
                
                // Restaurar contexto
                ctx.restore();
                ctx.shadowBlur = 0;
                
                // MANTENER: Efectos adicionales para powerups espec√≠ficos
                if (player.powerup === 'SHIELD') {
                    // Dibujar escudo protector animado
                    const shieldTime = Date.now() * 0.003;
                    ctx.strokeStyle = '#4444ff';
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 0.7 + Math.sin(shieldTime) * 0.3;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 8 + Math.sin(shieldTime) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
                
                if (player.powerup === 'SPEED') {
                    // Dibujar l√≠neas de velocidad
                    const speedLines = 6;
                    ctx.strokeStyle = '#44ff44';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    
                    for (let i = 0; i < speedLines; i++) {
                        const angle = (Math.PI * 2 * i) / speedLines + Date.now() * 0.01;
                        const lineLength = player.radius + 15;
                        const startX = player.x + Math.cos(angle) * player.radius;
                        const startY = player.y + Math.sin(angle) * player.radius;
                        const endX = player.x + Math.cos(angle) * lineLength;
                        const endY = player.y + Math.sin(angle) * lineLength;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }
                
                if (player.powerup === 'STRENGTH') {
                    // Dibujar part√≠culas de fuerza
                    const strengthTime = Date.now() * 0.008;
                    const particles = 8;
                    ctx.fillStyle = '#ff4444';
                    ctx.globalAlpha = 0.8;
                    
                    for (let i = 0; i < particles; i++) {
                        const angle = (Math.PI * 2 * i) / particles + strengthTime;
                        const distance = player.radius + 12 + Math.sin(strengthTime + i) * 8;
                        const particleX = player.x + Math.cos(angle) * distance;
                        const particleY = player.y + Math.sin(angle) * distance;
                        const particleSize = 3 + Math.sin(strengthTime * 2 + i) * 2;
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                }
                
                if (player.powerup === 'MAGNET') {
                    // Dibujar ondas magn√©ticas
                    const magnetTime = Date.now() * 0.004;
                    ctx.strokeStyle = '#ff44ff';
                    ctx.lineWidth = 2;
                    
                    for (let i = 1; i <= 3; i++) {
                        ctx.globalAlpha = 0.5 - (i * 0.1);
                        const waveRadius = player.radius + (i * 15) + Math.sin(magnetTime + i) * 5;
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, waveRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }
                
                // Show danger indicator when near edge
                const distFromCenter = Math.sqrt(Math.pow(player.x - centerX, 2) + Math.pow(player.y - centerY, 2));
                if (distFromCenter + player.radius > ringRadius - 50) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Player bet amount
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText(player.bet.toFixed(3), player.x, player.y + player.radius + 15);
                ctx.fillText(player.bet.toFixed(3), player.x, player.y + player.radius + 15);
                
                // MANTENER: Powerup indicator mejorado
                if (player.powerup) {
                    const type = POWERUP_TYPES[player.powerup];
                    
                    // Fondo del indicador
                    ctx.fillStyle = type.color;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y - player.radius - 15, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Emoji del powerup
                    ctx.font = '16px Arial';
                    ctx.fillStyle = 'white';
                    ctx.fillText(type.emoji, player.x, player.y - player.radius - 10);
                    
                    // Barra de tiempo restante
                    if (player.powerupEndTime) {
                        const remainingTime = Math.max(0, player.powerupEndTime - Date.now());
                        const totalTime = type.duration;
                        const timePercent = remainingTime / totalTime;
                        
                        if (timePercent > 0) {
                            const barWidth = 30;
                            const barHeight = 4;
                            const barX = player.x - barWidth / 2;
                            const barY = player.y - player.radius - 30;
                            
                            // Fondo de la barra
                            ctx.fillStyle = 'rgba(0,0,0,0.5)';
                            ctx.fillRect(barX, barY, barWidth, barHeight);
                            
                            // Barra de progreso
                            ctx.fillStyle = type.color;
                            ctx.fillRect(barX, barY, barWidth * timePercent, barHeight);
                        }
                    }
                }
                
                // Player is you indicator
                if (player.id === gameState.myPlayerId) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Mostrar n√∫mero de personaje para debug
                if (GAME_CONFIG.testMode) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText(`P${player.characterIndex}`, player.x, player.y - player.radius - 35);
                }
            });
            
            // Draw countdown
            if (gameState.gamePhase === 'countdown') {
                ctx.fillStyle = '#FFD700';
                ctx.font = '72px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.countdown || 'FIGHT!', centerX, centerY);
            }
        }

        // A√ëADIR funci√≥n para mostrar estad√≠sticas en modo debug
        function updateUI() {
            document.getElementById('prizePool').textContent = gameState.prizePool.toFixed(3);
            document.getElementById('playerCount').textContent = gameState.players.size;
            
            // Update timer
            if (gameState.gamePhase === 'countdown') {
                document.getElementById('gameTimer').textContent = gameState.countdown || 'FIGHT!';
            } else if (gameState.gamePhase === 'playing') {
                const alivePlayers = getAlivePlayers();
                let timerText = `${gameState.gameTime}s`;
                
                // Mostrar informaci√≥n de jugadores vivos
                timerText += ` (${alivePlayers.length} alive)`;
                
                // A√ëADIR: Indicador especial cuando queda un solo jugador
                if (alivePlayers.length === 1) {
                    timerText += ' üèÜ WINNER!';
                }
                
                // En modo de prueba, mostrar informaci√≥n adicional
                if (GAME_CONFIG.testMode) {
                    if (alivePlayers.length === 1) {
                        timerText += ' [TEST MODE - SUCCESS]';
                    } else {
                        timerText += ' [TEST MODE]';
                    }
                }
                
                document.getElementById('gameTimer').textContent = timerText;
            } else if (gameState.gamePhase === 'waiting') {
                document.getElementById('gameTimer').textContent = 'Waiting... (Use WASD to move)';
            } else if (gameState.gamePhase === 'finished') {
                const alivePlayers = getAlivePlayers();
                if (alivePlayers.length === 1) {
                    document.getElementById('gameTimer').textContent = `üèÜ Winner: ${alivePlayers[0].address.substring(0, 8)}...`;
                } else {
                    document.getElementById('gameTimer').textContent = 'Game Finished';
                }
            } else {
                document.getElementById('gameTimer').textContent = 'Waiting...';
            }
            
            // Update player list
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '';
            gameState.players.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.style.opacity = player.alive ? '1.0' : '0.5'; // Dim eliminated players
                
                // A√ëADIR: Destacar al ganador
                if (player.alive && getAlivePlayers().length === 1 && gameState.gamePhase === 'playing') {
                    card.style.border = '2px solid #FFD700';
                    card.style.background = 'rgba(255, 215, 0, 0.2)';
                }
                
                // MODIFICAR: Mostrar informaci√≥n del tama√±o
                const sizeInfo = `(Size: ${player.radius.toFixed(0)})`;
                
                card.innerHTML = `
                    <div style="color: ${player.color}">‚óè</div>
                    <div>${player.address.substring(0, 6)}...</div>
                    <div>${player.bet.toFixed(3)} FLOW</div>
                    <div style="font-size: 10px; color: #ccc;">${sizeInfo}</div>
                    <div>${player.alive ? (getAlivePlayers().length === 1 && gameState.gamePhase === 'playing' ? 'üëë' : 'üü¢') : 'üíÄ'}</div>
                `;
                playerList.appendChild(card);
            });
        }

        function getAlivePlayers() {
            return Array.from(gameState.players.values()).filter(p => p.alive);
        }

        // Update UI periodically
        setInterval(updateUI, 100);

        function spawnPowerup() {
            if (gameState.powerups.length < 3) {
                const types = Object.keys(POWERUP_TYPES);
                const type = types[Math.floor(Math.random() * types.length)];
                
                // Spawn inside the ring but not too close to center
                const angle = Math.random() * Math.PI * 2;
                const minRadius = ringRadius * 0.2; // Minimum distance from center
                const maxRadius = ringRadius * 0.7; // Not too close to edge
                const distance = minRadius + Math.random() * (maxRadius - minRadius);
                
                gameState.powerups.push({
                    type: type,
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    rotation: 0
                });
            }
        }

        // Add a simple message display function
        function showMessage(text, duration = 2000) {
            const message = document.createElement('div');
            message.style.position = 'absolute';
            message.style.top = '20px';
            message.style.left = '50%';
            message.style.transform = 'translateX(-50%)';
            message.style.background = 'rgba(0,0,0,0.7)';
            message.style.color = 'white';
            message.style.padding = '10px 20px';
            message.style.borderRadius = '20px';
            message.style.fontWeight = 'bold';
            message.style.zIndex = '1000';
            message.textContent = text;
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.style.opacity = '0';
                message.style.transition = 'opacity 0.5s';
                setTimeout(() => document.body.removeChild(message), 500);
            }, duration);
        }

        // A√±adir esta nueva funci√≥n
        function updateGameStateFromServer(serverState) {
            console.log('Estado recibido del servidor:', serverState);
            console.log('N√∫mero de jugadores:', serverState.players.length);
            console.log('Fase del juego:', serverState.gamePhase);
            console.log('Juego corriendo:', serverState.gameRunning);
            
            // Actualizar el estado del juego con los datos del servidor
            gameState.gameRunning = serverState.gameRunning;
            gameState.gamePhase = serverState.gamePhase;
            gameState.prizePool = serverState.prizePool;
            gameState.countdown = serverState.countdown;
            gameState.gameTime = serverState.gameTime;
            
            // Actualizar tracking de personajes basado en los jugadores del servidor
            assignedCharacters.clear();
            
            // Convertir el array de jugadores en un Map
            const newPlayers = new Map();
            serverState.players.forEach(player => {
                // Asegurar que el jugador tenga un personaje asignado
                if (!player.characterIndex) {
                    player.characterIndex = getNextAvailableCharacter();
                } else {
                    assignedCharacters.add(player.characterIndex);
                }
                
                newPlayers.set(player.id, player);
                
                // Si este jugador soy yo, guardar mi ID
                if (player.address === walletAddress) {
                    gameState.myPlayerId = player.id;
                }
            });
            gameState.players = newPlayers;
            
            // Actualizar powerups
            gameState.powerups = serverState.powerups;
            
            // Actualizar UI
            updateUI();
            
            // L√ìGICA MEJORADA para mostrar/ocultar el bot√≥n Start Game
            console.log('Verificando condiciones para mostrar bot√≥n Start Game:');
            console.log('- Jugadores:', gameState.players.size);
            console.log('- M√≠nimo requerido:', GAME_CONFIG.minPlayers);
            console.log('- Fase del juego:', gameState.gamePhase);
            console.log('- Juego corriendo:', gameState.gameRunning);
            
            const shouldShowStartButton = 
                gameState.players.size >= GAME_CONFIG.minPlayers && 
                (gameState.gamePhase === 'waiting' || gameState.gamePhase === '' || !gameState.gamePhase) && 
                !gameState.gameRunning;
                
            console.log('¬øMostrar bot√≥n Start?', shouldShowStartButton);
            
            if (shouldShowStartButton) {
                document.getElementById('startGame').style.display = 'inline-block';
                
                // A√±adir indicador de modo prueba si corresponde
                if (GAME_CONFIG.testMode && gameState.players.size === 1) {
                    document.getElementById('startGame').textContent = 'Start Game (Test Mode)';
                } else {
                    document.getElementById('startGame').textContent = 'Start Game';
                }
            } else {
                document.getElementById('startGame').style.display = 'none';
            }
            
            // Desactivar el bot√≥n Join Game si ya estamos en el juego
            if (gameState.myPlayerId && gameState.players.has(gameState.myPlayerId)) {
                document.getElementById('joinGame').disabled = true;
                document.getElementById('joinGame').textContent = 'Joined ‚úì';
            } else {
                // Ensure join game button is enabled and text is reset if player is not in game
                document.getElementById('joinGame').disabled = false;
                document.getElementById('joinGame').textContent = 'Join Game';
            }
        }
    </script>
</body>
</html>